/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.validation

import com.google.inject.Inject
import com.regnosys.rosetta.tests.RosettaInjectorProvider
import com.regnosys.rosetta.tests.util.ModelHelper
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*

@ExtendWith(InjectionExtension)
@InjectWith(RosettaInjectorProvider)
class RosettaValidatorTest implements RosettaIssueCodes {

	@Inject extension ValidationTestHelper
	@Inject extension ModelHelper
	
	@Test
	def void testCanPutCustomErrorsOnElements() {
		val model =
		'''
			func Add: 
				inputs:
					a int (1..1) <"Documentation">
					b int (1..1)
				output: result int (1..1)
				set result:
					a + b
			
			<ERROR on 'inputs' 1 back "My custom error">
		'''.parseRosetta
		model.assertError(PLAYGROUND_ELEMENT, null,
            "My custom error")
	}
	
	@Test
	def void testLocationMustExist() {
		val model =
		'''
			<ERROR on 'id' back "Invalid location">
			
			id id
			
			<INFO on 'id' 2 back "Information">
		'''.parseRosetta
		model.assertError(PLAYGROUND_LOCATION, null,
            "Not found.")
	}
	
	@Test
	def void testNoErrors() {
		val model =
		'''
			namespace foo
			
			reporting rule Rule:
			  [docReference ]
			
			  extract Product from ReportableEvent:
			    from TradeForEvent
			    extract tradeableProduct -> product
			    then
			        if it HasUnderlier
			        then UnderlierForProduct
			        else 42
			
			<INLAY on 'tradeableProduct' 1 back "Trade ->">
			<INLAY on 'it' 1 back "Trade">
		'''.parseRosetta
		model.assertNoIssues
	}
}
