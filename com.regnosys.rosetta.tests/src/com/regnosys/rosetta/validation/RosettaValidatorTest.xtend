/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.validation

import com.google.inject.Inject
import com.regnosys.rosetta.RosettaRuntimeModule
import com.regnosys.rosetta.rosetta.simple.Data
import com.regnosys.rosetta.tests.RosettaInjectorProvider
import com.regnosys.rosetta.tests.util.ModelHelper
import org.eclipse.xtext.service.SingletonBinding
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.xtext.validation.Check
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*
import static com.regnosys.rosetta.rosetta.simple.SimplePackage.Literals.*

@ExtendWith(InjectionExtension)
@InjectWith(MyRosettaInjectorProvider)
class RosettaValidatorTest implements RosettaIssueCodes {

	@Inject extension ValidationTestHelper
	@Inject extension ModelHelper
	
	@Test
	def void testLowerCaseClass() {
		val model =
		'''
			synonym source FIX
			synonym source FpML
			
			type partyIdentifier: <"">
				partyId string (1..1) <"">
					[synonym FIX value "PartyID" tag 448]
					[synonym FpML value "partyId"]
		'''.parseRosettaWithNoErrors
		model.assertWarning(DATA, INVALID_CASE,
            "Type name should start with a capital")
	}
	
	@Test
	def void testLowerCaseEnumeration() {
		val model =
		'''
			enum quoteRejectReasonEnum: <"">
				UnknownSymbol
				Other
		'''.parseRosettaWithNoErrors
		model.assertWarning(ROSETTA_ENUMERATION, INVALID_CASE,
            "Enumeration name should start with a capital")
	}
	
	@Test
	def void testUpperCaseAttribute() {
		val model =
		'''
			synonym source FIX
			synonym source FpML
			type PartyIdentifier: <"">
					PartyId string (1..1) <"">
						[synonym FIX value "PartyID" tag 448]
						[synonym FpML value "partyId"]
		'''.parseRosettaWithNoErrors
		model.assertWarning(ATTRIBUTE, INVALID_CASE,
            "Attribute name should start with a lower case")
	}
		
	@Test
	def void testTypeExpectation() {
		val model =
		'''
			type Foo:
				id int (1..1)
			
				condition R: 
					if id = True
					then id < 1
		'''.parseRosetta
		model.assertError(ROSETTA_CONDITIONAL_EXPRESSION, TYPE_ERROR, 
			"Incompatible types: cannot use operator '=' with int and boolean.")
	}
	
	@Test
	def void testTypeExpectationMagicType() {
		'''
			qualifiedType productType {}
			type Foo:
				id productType (1..1)
				val int (1..1)
			
			condition R:
				if  id = "Type"
				then val < 1
		'''.parseRosettaWithNoErrors
	}
	
	@Test
	def void testTypeExpectationNoError() {
		val model =
		'''
			type Foo:
				id int (1..1)
			
			condition R:
				if id = 1
				then id < 1
		'''.parseRosettaWithNoErrors
		model.assertNoError(TYPE_ERROR)
	}
	
	@Test
	def void testTypeExpectationError() {
		val model =
		'''
			type Foo:
				id boolean (1..1)
			condition R:
				if id = True
				then id < 1
		'''.parseRosetta
		model.assertError(ROSETTA_CONDITIONAL_EXPRESSION, TYPE_ERROR, "Incompatible types: cannot use operator '<' with boolean and int.")
	}
	
	@Test
	def void testTypeErrorAssignment_01() {
		val model =
		'''
			namespace "test"
			version "test"
			
			type Foo:
				id boolean (1..1)
			
			func Test:
				inputs: in0 Foo (0..1)
				output: out Foo (0..1)
				assign-output out:
					"not a Foo"
		'''.parseRosetta
		model.assertError(OPERATION, TYPE_ERROR, "Expected type 'Foo' but was 'string'")
	}
	
	
	@Test
	def void testTypeErrorAssignment_02() {
		val model =
		'''
			type Foo:
				id boolean (1..1)
			
			func Test:
				inputs: in0 Foo (0..1)
				output: out Foo (0..1)
				assign-output out -> id:
					"not a boolean"
		'''.parseRosetta
		model.assertError(OPERATION, TYPE_ERROR, "Expected type 'boolean' but was 'string'")
	}
	
	@Test
	def void testTypeErrorAssignment_03() {
		val model =
		'''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
			
			func Bar:
			  inputs:
			    in1 TypeToUse (1..1)
			  output: result TypeToUse (1..1)
			  assign-output result -> attr:
			     in1 as-key
		'''.parseRosetta
		model.assertError(OPERATION, TYPE_ERROR, "Expected type 'WithKey' but was 'TypeToUse'")
	}
	
	@Test
	def void testTypeErrorAssignment_04() {
		val model =
		'''
			enum Enumerate : X Y Z

			type Type:
				other Enumerate (0..1)

			func Funcy:
				inputs: in0 Type (0..1)
				output: out string (0..1)
				alias Ali : in0 -> other = Enumerate -> X
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def void testTypeErrorAssignment_05() {
		val model =
		'''
			type Type:
				other int (0..1)

			func Funcy:
				inputs: in0 Type (0..1)
				output: out string (0..1)
				assign-output out: in0->other
		'''.parseRosetta
		model.assertError(OPERATION, TYPE_ERROR, "Expected type 'string' but was 'int'")
	}
	
	@Test
	def void testAttributesWithLocationBadTarget() {
		'''
			metaType scheme string
			metaType reference string
			
			type Bar:
				bar string (1..1)
					[metadata address "pointsTo"=Foo->foo]
			
		'''.parseRosetta
		//TODO work out how to assert linking error
		//model.assertError(ROSETTA_CALLABLE_CALL, null, "Couldn't resolve reference to RosettaCallable 'Foo' on RosettaCallableCall")
	}
	
	@Test
	def void testAttributesWithLocationAndNoAddress() {
		val model ='''
			metaType scheme string
			metaType reference string
			
			type Foo:
				foo string (1..1) 
			
			type Bar:
				bar string (1..1)
					[metadata address "pointsTo"=Foo->foo]
			
		'''.parseRosetta
		model.assertError(ANNOTATION_QUALIFIER, null, "Target of address must be annotated with metadata location")
	}
	
	@Test
	def void testAttributesWithLocationAndAddressWrongType() {
		val model ='''
			metaType scheme string
			metaType reference string

			type Foo:
				foo int (1..1) 
					[metadata location]
			
			type Bar:
				bar string (1..1)
					[metadata address "pointsTo"=Foo->foo]
			
		'''.parseRosetta
		model.assertError(ANNOTATION_QUALIFIER, TYPE_ERROR, "Expected address target type of 'string' but was 'int'")
	}
	

	@Test
	def void testDuplicateAttribute() {
		val model = '''
			type Foo:
				i int (1..1)
			
			type Bar extends Foo:
				i int (1..1)
		'''.parseRosetta
		model.assertError(ATTRIBUTE, DUPLICATE_ATTRIBUTE, 'Duplicate attribute')
	}
	
	@Test
	def void testDuplicateAttributeWithOverride() {
		val model = '''
			type A1 :
				i int (1..1)
			
			
			type A2 extends A1 :
				j int (1..1)
			
			
			
			type Foo:
				f A1 (1..1)
			
			type Bar extends Foo:
				override f A2 (1..1)
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def void testDuplicateAttributeWithOverrideBadTypes() {
		val model = '''
			type A1 :
				i int (1..1)
			
			
			type A2 extends A1 :
				j int (1..1)
			
			type A3 :
				j int (1..1)

			
			type Foo:
				f A1 (1..1)
			
			type Bar extends Foo:
				override f A3 (1..1)
		'''.parseRosetta
		model.assertError(ATTRIBUTE, DUPLICATE_ATTRIBUTE, '''Overriding attribute 'f' must have a type that overrides its parent attribute type of A1''')
	}
	
	@Test
	def void testDuplicateBasicTypeAttributeWithOverrideBadTypes() {
		val model = '''
			type Foo:
				i int (1..1)
			
			type Bar extends Foo:
				override i string (1..1)
		'''.parseRosetta
		
		model.assertError(ATTRIBUTE, DUPLICATE_ATTRIBUTE, '''Overriding attribute 'i' must have a type that overrides its parent attribute type of int''')
	}

	@Test
	def void testDuplicateAttributeWithOverrideWithDifferentCardinality() {
		val model = '''
			type A1 :
				i int (1..1)
			
			type A2 extends A1 :
				j int (1..1)
			
			type Foo:
				f A1 (1..1)
			
			type Bar extends Foo:
				override f A2 (0..1)
		'''.parseRosetta
			
		model.assertError(ATTRIBUTE, CARDINALITY_ERROR, '''Overriding attribute 'f' with cardinality (0..1) must match the cardinality of the attribute it overrides (1..1)''')
	}

		
	@Test
	def void testDuplicateAttributeWithOverrideWithUnboundedCardinality() {
		val model = '''
			type A1 :
				i int (1..1)
			
			type A2 extends A1 :
				j int (1..1)
			
			type Foo:
				f A1 (1..*)
			
			type Bar extends Foo:
				override f A2 (1..1)
		'''.parseRosetta
			
		model.assertError(ATTRIBUTE, CARDINALITY_ERROR, '''Overriding attribute 'f' with cardinality (1..1) must match the cardinality of the attribute it overrides (1..*)''')
	}
		
	@Test
	def void testDuplicateEnumLiteral() {
		val model = '''
			enum Foo:
				BAR BAZ BAR
		'''.parseRosetta
		model.assertError(ROSETTA_ENUM_VALUE, DUPLICATE_ENUM_VALUE, 'Duplicate enum value')
	}
	
	@Test 
	def void testDuplicateType() {
		val model = '''
			type Bar:
			
			type Foo:
			
			enum Foo: BAR
		'''.parseRosetta
		model.assertError(ROSETTA_TYPE, DUPLICATE_ELEMENT_NAME, 'Duplicate element name')
	}
		
	@Test
	def void testDuplicateChoiceRuleAttribute_thisOne() {
		val model = '''
			type Bar:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
				condition Foo:
					required choice
					attribute1, attribute1
		'''.parseRosetta
		model.assertError(CONDITION, DUPLICATE_CHOICE_RULE_ATTRIBUTE, 'Duplicate attribute')
	}
	
	@Test
	def void testDuplicateChoiceRuleAttribute_thatOne() {
		val model = '''
			type Bar:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
			condition Foo:
				required choice attribute1 , attribute2 , attribute2
		'''.parseRosetta
		model.assertError(CONDITION, DUPLICATE_CHOICE_RULE_ATTRIBUTE, 'Duplicate attribute')
	}
	
	@Test
	def void testClassWithChoiceRuleAndOneOfRule() {
		val model = '''
			type Foo:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
				condition Foo_oneOfRule: one-of
				condition Foo_choiceRule:
					required choice
						attribute1, attribute2
		'''.parseRosetta
		model.assertError(DATA, CLASS_WITH_CHOICE_RULE_AND_ONE_OF_RULE, 'Type Foo has both choice condition and one-of condition.')
	}


 	@Test
	def checkMappingMultipleSetToWithoutWhenCases() {
		val model = '''
			type Quote:
				attr int (1..1)
					[synonym FIX 
							set to 1,
							set to 2]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Only one set to with no when clause allowed.")
	}
	
	@Test
	def checkMappingMultipleSetToOrdering() {
		val model = '''
			type Quote:
				attr int (1..1)
					[synonym FIX 
							set to 1,
							set to 2 when "a.b.c" exists]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to without when case must be ordered last.")
	}
	
	@Test
	def checkMappingSetToTypeCheck() {
		val model = '''
			type Foo:
				value0 string (1..1)
			
			type Quote:
				attr Foo (1..1)
					[synonym FIX 
							set to "hello"]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to constant type does not match type of field.")
	}
	
	@Test
	def checkMappingSetToEnumTypeCheck() {
		val model = '''
			enum Foo: ONE
			

			enum Bar: BAR
			
			type Quote:
				attr Foo (1..1)
					[synonym FIX 
							set to Bar.BAR]
		'''.parseRosetta
		model.assertError(ROSETTA_MAPPING, null, "Set to constant type does not match type of field.")
	}
	
	@Test
	def checkMappingSetToWhenTypeCheck() {
		val model = '''
			synonym source FpML
			type Foo:
				stringVal string (1..1)
			
			type Quote:
				attr Foo (1..1)
					[synonym FpML value "foo" set when "foo->bar" exists]
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def checkOperationTypes() {
		val model = '''
			type Clazz:
				test boolean (0..1)
			
				condition DataRule:
					if test = True 
						or False <> False
						or 1 > 0
						or 1 < 0
						or 1 >= 0
						or 1 <= 0
						or 1 <> 0
						or 1 = 0
					then 1.1 = .0
						and 0.2 <> 0.1
						and 0.2 > 0.1
						and 0.2 < 0.1
						and 0.2 <= 0.1
						and 0.2 >= 0.1
		'''.parseRosetta
		model.assertNoErrors
	}	
	
	@Test
	def checkDateZonedDateTypes() {
		val model = '''
			recordType date{}
			recordType zonedDateTime{}
			
			func Foo:
			  inputs:
			    timestamp zonedDateTime (1..1)
			  output: result date (1..1)
			
			func Bar:
			  inputs:
			    timestamp date (1..1)
			  output: result boolean (1..1)
			  assign-output result:
			     Foo(timestamp) = timestamp
			
		'''.parseRosetta
		model.assertError(ROSETTA_CALLABLE_WITH_ARGS_CALL, TYPE_ERROR, 
			"Expected type 'zonedDateTime' but was 'date'")
	}
	
	@Test
	def checkAsKeyUsage_01() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			  output: result TypeToUse (1..1)
			  assign-output result -> attr:
			     in0 as-key
		'''.parseRosetta
		model.assertNoErrors
	}
	
	@Test
	def checkAsKeyUsage_02() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
				attr2 TypeToUse (0..1)
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			    in1 TypeToUse (1..1)
			  output: result TypeToUse (1..1)
			  assign-output result -> attr2:
			     in1 as-key
		'''.parseRosetta
		model.assertError(SEGMENT, null,
			"'as-key' can only be used with attributes annotated with [metadata reference] annotation.")
	}
	
	@Test
	def checkAsKeyUsage_03() {
		val model = '''
			type WithKey:
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
		'''.parseRosetta
		model.assertWarning(ATTRIBUTE, null,
			"WithKey must be annotated with [metadata key] as reference annotation is used")
	}
	
	@Test
	def checkAsKeyUsage_04() {
		val model = '''
			type WithKey:
				[metadata key]
			
			type TypeToUse:
				attr WithKey (0..1)
				[metadata reference]
			
			func Bar:
			  inputs:
			    in0 WithKey (1..1)
			  output: result WithKey (1..1)
			  assign-output result:
			     in0 as-key
		'''.parseRosetta
		model.assertError(OPERATION, null,
			"'as-key' can only be used when assigning an attribute. Example: \"assign-output out -> attribute: value as-key\"")
	}
	
	@Test
	def checkSynonymPathSyntax_01() {
		val model = '''
			type TypeToUse:
				attr string (0..1)
				[synonym FpML value "adjustedDate" path "relative.date" meta id]
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_VALUE_BASE, null,
			"Character '.' is not allowed in paths. Use '->' to separate path segments.")
	}

	@Test
	def checkSynonymPathSyntax_02() {
		val model = '''
			type TypeToUse:
				attr string (0..1)
				[synonym FpML set to "Custom" when "Pty+Src" = "D"]
		'''.parseRosetta
		model.assertError(ROSETTA_MAP_PATH_VALUE, null,
			"Character '+' is not allowed in paths. Use '->' to separate path segments.")
	}

	@Test
	def checkChoiceConditionAttributes() {
		val model = '''
			type Bar:
				attribute1 string (0..1)
				attribute2 string (0..1)
				attribute3 string (0..1)
			
				condition:
					required choice
					attribute1
		'''.parseRosetta
		model.assertError(CONSTRAINT, null,
			"At least two attributes must be passed to a choice rule.")
	}
	
	
	
	@Test
	def void externalSynonymWithFormatShouldOnlyOnDate() {
	val model='''
			type Foo:
				foo int (0..1)
			
			synonym source TEST_Base
			
			synonym source TEST extends TEST_Base {
				
				Foo:
					+ foo
						[value "bar" path "baz" dateFormat "MM/dd/yy"]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Format can only be applied to date/time types")
	}
	
	@Test
	def void externalSynonymWithFormatValid() {
	val model='''
			type Foo:
				foo time (0..1)
			
			synonym source TEST_Base
			
			synonym source TEST extends TEST_Base {
				
				Foo:
					+ foo
						[value "bar" path "baz" dateFormat "MMB/dd/yy"]
			}
		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Format must be a valid date/time format - Unknown pattern letter: B")
	}
	
	@Test
	def void internalSynonymWithFormatShouldOnlyBeOnDate() {
	val model='''
			type Foo:
				foo int (0..1)
				[synonym TEST_Base value "bar" path "baz" dateFormat "MM/dd/yy"]
			synonym source TEST_Base

		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Format can only be applied to date/time types")
	}
	
	@Test
	def void internalSynonymWithPatternShouldBeValid() {
	val model='''
			type Foo:
				foo int (0..1)
				[synonym TEST_Base value "bar" path "baz" pattern "([A-Z)" "$1"]
			synonym source TEST_Base

		'''.parseRosetta
		model.assertError(ROSETTA_SYNONYM_BODY, null,
			"Pattern to match must be a valid regular expression")
	}
	
	@Test
	def void testFishIsAShark() {//This test tests that when a check throws an exception it is translated into a validation error - see ExceptionValidator below
	val model='''
			type MyFish:
				foo int (0..1)
				[synonym TEST_Base value "bar" path "baz" pattern "([A-Z)" "$1"]
			synonym source TEST_Base

		'''.parseRosetta
		model.assertError(ROSETTA_TYPE, null,
			"checkForSharks")
	}
	
	@Test
	def void enumSynonymWithPatternShouldBeValid() {
	val model='''
			enum Enumerate : X Y Z
			
			synonym source TEST_Base
			synonym source TEST extends TEST_Base {
				
				enums
				
				Enumerate:
					+ x
						[value "bar" pattern "([A-Z)" "$1"]
			}

		'''.parseRosetta
		model.assertError(ROSETTA_ENUM_SYNONYM, null,
			"Pattern to match must be a valid regular expression")
	}
	
	@Test
	def shouldGenerateRuleCardinalityWarning() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule Aa
				extract Bar->bar1 as "A"
			
			type Bar:
				bar1 string (0..*)
			
			type BarReport:
				aa string (1..1)
					[ruleReference Aa]
		'''.parseRosetta
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field aa has single cardinality whereas the reporting rule Aa has multiple cardinality.")
	}

	@Test
	def shouldGenerateRuleTypeError() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->barA exists
			
			reporting rule Aa
				extract Bar->barA as "A"

			reporting rule Bb
				extract Bar->barB as "B"
				
			reporting rule Cc
				extract Bar->barC as "C"

			reporting rule Dd
				extract Bar->barD as "D"

			reporting rule Ee
				extract Bar->barE as "E"
				
			reporting rule Ff
				extract Bar->barF as "F"
			
			type Bar:
				barA date (0..1)
				barB time (0..1)
				barC zonedDateTime (0..1)
				barD int (0..1)
				barE number (0..1)
				barF BazEnum (0..1)

			enum BazEnum:
				X
				Y
				Z
			
			type BarReport:
				aa string (1..1)
					[ruleReference Aa]
				bb string (1..1)
					[ruleReference Bb]
				cc string (1..1)
					[ruleReference Cc]
				dd string (1..1)
					[ruleReference Dd]
				ee string (1..1)
					[ruleReference Ee]
				ff string (1..1)
					[ruleReference Ff]
			
		'''.parseRosetta
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field aa has type string whereas the reporting rule Aa has type date.")
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field bb has type string whereas the reporting rule Bb has type time.")
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field cc has type string whereas the reporting rule Cc has type zonedDateTime.")
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field dd has type string whereas the reporting rule Dd has type int.")
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field ee has type string whereas the reporting rule Ee has type number.")
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field ff has type string whereas the reporting rule Ff has type BazEnum.")
	}
	
	@Test
	def shouldGenerateRuleTypeError2() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->barA exists
			
			reporting rule Aa
			(
				extract Bar->barA as "A",
				extract Bar->barB as "B"
			)
			
			type Bar:
				barA string (0..1)
				barB number (0..1)
			
			type BarReport:
				aa string (1..1)
					[ruleReference Aa]
			
		'''.parseRosetta
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field aa has single cardinality whereas the reporting rule Aa has multiple cardinality.")
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field aa has type string whereas the reporting rule Aa has type Object.")
	}
	
	@Test
	def shouldNotGenerateRuleTypeErrorUsingReturn() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule A
				return "Not Modelled" 
					as "A"
			
			type Bar:
				bar1 string (0..1)
			
			type BarReport:
				a string (1..1)
					[ruleReference A]
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}

	@Test
	def void shouldNotGenerateTypeValidationError() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule BarBarOne
				(
					filter when Bar->test = True then extract Bar->bar1,
					filter when Bar->test = False then extract Bar->bar2
				)  as "1 BarOne"
			
			type Bar:
				test boolean (1..1)
				bar1 string (1..1)
				bar2 string (1..1)
			
			type BarReport:
				barBarOne string (1..1)
					[ruleReference BarBarOne]
			
		'''.parseRosetta
		model.assertNoErrors
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field barBarOne has single cardinality whereas the reporting rule BarBarOne has multiple cardinality.")
	}
	
	@Test
	def void shouldNotGenerateTypeValidationError2() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule BarBarOne
				(
					filter when Bar->test = True then extract Bar->bar1 + Bar->bar2,
					filter when Bar->test = False then extract Bar->bar2
				)  as "1 BarOne"
			
			type Bar:
				test boolean (1..1)
				bar1 string (1..1)
				bar2 string (1..1)
			
			type BarReport:
				barBarOne string (1..1)
					[ruleReference BarBarOne]
			
		'''.parseRosetta
		model.assertNoErrors
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field barBarOne has single cardinality whereas the reporting rule BarBarOne has multiple cardinality.")
	}
	
	@Test
	def void shouldNotGenerateTypeValidationError3() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule BarBarOne
				(
					filter when Bar->test = True then extract Bar->bar1 * Bar->bar2,
					filter when Bar->test = False then extract Bar->bar2
				)  as "1 BarOne"
			
			type Bar:
				test boolean (1..1)
				bar1 number (1..1)
				bar2 number (1..1)
			
			type BarReport:
				barBarOne number (1..1)
					[ruleReference BarBarOne]
			
		'''.parseRosetta
		model.assertNoErrors
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field barBarOne has single cardinality whereas the reporting rule BarBarOne has multiple cardinality.")
	}
	
	@Test
	def void shouldNotGenerateTypeValidationError4() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule BarBarOne
				(
					filter when Bar->test = True then extract Bar->bar1,
					filter when Bar->test = False then extract Bar->bar2
				)  as "1 BarOne"
			
			type Bar:
				test boolean (1..1)
				bar1 number (1..1)
				bar2 int (1..1)
			
			type BarReport:
				barBarOne number (1..1)
					[ruleReference BarBarOne]
			
		'''.parseRosetta
		model.assertNoErrors
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field barBarOne has single cardinality whereas the reporting rule BarBarOne has multiple cardinality.")
	}

	@Test
	def void shouldNotGenerateTypeValidationError5() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule BarBarOne
				(
					filter when Bar->test = True then extract Bar->bar1,
					filter when Bar->test = False then extract Bar->bar2
				)  as "1 BarOne"
			
			type Bar:
				test boolean (1..1)
				bar1 Baz (1..1)
				bar2 Baz (1..1)
			
			type Baz:
				baz1 number (1..1)
			
			type BarReport:
				barBarOne Baz (1..1)
					[ruleReference BarBarOne]
			
		'''.parseRosetta
		model.assertNoErrors
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field barBarOne has single cardinality whereas the reporting rule BarBarOne has multiple cardinality.")
	}
	
	@Test
	def void shouldGenerateTypeValidationErrorDifferentDataType() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule BarBarOne
				(
					filter when Bar->test = True then extract Bar->bar1,
					filter when Bar->test = False then extract Bar->bar2
				)  as "1 BarOne"
			
			type Bar:
				test boolean (1..1)
				bar1 Baz (1..1)
				bar2 Qux (1..1)
			
			type Baz:
				baz1 number (1..1)
			
			type Qux:
				qux1 int (1..1)
			
			type BarReport:
				barBarOne Baz (1..1)
					[ruleReference BarBarOne]
			
		'''.parseRosetta
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Type mismatch - report field barBarOne has type Baz whereas the reporting rule BarBarOne has type Object.")
		model.assertWarning(ROSETTA_RULE_REFERENCE, null, "Cardinality mismatch - report field barBarOne has single cardinality whereas the reporting rule BarBarOne has multiple cardinality.")
	}


	@Test
	def shouldGenerateDuplicateRuleError() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule A
				return "Not Modelled" 
					as "A"
			
			type Bar:
				bar1 string (0..1)
			
			type BarReport:
				a string (1..1)
					[ruleReference A]
				b string (1..1)
					[ruleReference A]
		'''.parseRosetta
		model.assertError(ROSETTA_RULE_REFERENCE, null, "Duplicate reporting rule A")
	}
	
	@Test
	def shouldGenerateUnsupportedCardinalityError() {
		val model = '''
			body Authority TEST_REG
			corpus TEST_REG MiFIR
			
			report TEST_REG MiFIR in T+1
			when FooRule
			with type BarReport
			
			eligibility rule FooRule
				filter when Bar->bar1 exists
			
			reporting rule A
				extract Bar->bar1 as "A"
			
			type Bar:
				bar1 string (0..*)
			
			type BarReport:
				a string (0..*)
					[ruleReference A]
		'''.parseRosetta
		model.assertError(ATTRIBUTE, null, "Report attributes with basic type (string) and multiple cardinality is not supported.")
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorForMap() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				attr string (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					fooCounts int (0..*)
				
				set fooCounts:
					bars 
						map bar [ bar -> foos ]
						map foosItem [ foosItem count ]
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorDefaultParameterForMap() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				attr string (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					fooCounts int (0..*)
				
				set fooCounts:
					bars 
						map [ item -> foos ]
						map [ item count ]
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorForNestedMap() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result boolean (1..1)
				
				alias results:
					bars -> foos
						map [ item -> amount > 0 ]
				
				assign-output result:
					results all = True
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def shouldNotGenerateCountCardinalityErrorDefaultParameterForNestedMap() {
		val model = '''
			type Bar:
				foos Foo (0..*)

			type Foo:
				amount number (1..1)
			
			func FuncFoo:
			 	inputs:
			 		bars Bar (0..*)
				output:
					result boolean (1..1)
				
				alias results:
					bars -> foos
						map foo [ foo -> amount > 0 ]
				
				assign-output result:
					results all = True
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}

	@Test
	def void shouldNotGenerateCardinalityWarning() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		n1 number (0..1)
			 		n2 number (0..1)
			 		n3 number (0..1)
				output:
					result boolean (0..1)
				
				assign-output result:
					if n1 exists and n2 exists and n3 exists
					then n1 + n2 = n3
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldNotGenerateCardinalityWarning2() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		n1 number (0..1)
			 		n2 number (0..1)
			 		n3 number (0..1)
				output:
					result boolean (0..1)
				
				alias n3Alias:
					GetNumberList( n3 ) only-element
				
				assign-output result:
					n1 + n2 = n3Alias
					
			func GetNumberList:
				inputs:
					x number (1..1)
				output:
					xs number (0..*)
		'''.parseRosetta
		model.assertNoErrors
		model.assertNoIssues
	}
	
	@Test
	def void shouldGenerateListFilterNoExpressionError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (0..*)
				output:
					filteredFoo Foo (0..*)
				
				assign-output filteredFoo:
					foo
						filter
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(LIST_OPERATION, null, "List filter must have a boolean expression specified within square brackets.")
	}
	
	@Test
	def void shouldGenerateListFilterExpressionTypeError() {
		val model = '''
			func FuncFoo:
			 	inputs:
			 		foo Foo (0..*)
				output:
					filteredFoo Foo (0..*)
				
				assign-output filteredFoo:
					foo
						filter [ item -> x ]
			
			type Foo:
				x string (1..1)
		'''.parseRosetta
		model.assertError(LIST_OPERATION, null, "List filter expression must evaluate to a boolean.")
	}
}
	
class MyRosettaInjectorProvider extends RosettaInjectorProvider {
	override createRuntimeModule() {
		return new RosettaRuntimeModule(){
			override bindClassLoaderToInstance() {
				return MyRosettaInjectorProvider
						.getClassLoader();
			}
			
			@SingletonBinding(eager=true)
			override Class<? extends RosettaValidator> bindRosettaValidator() {
				return ExceptionValidator
			}
		}
	}
}

class ExceptionValidator extends RosettaValidator{
	@Check
	def checkForSharks(Data ele) {
		if (ele.name.contains("Fish")) throw new Exception("SHARK!")
		
	}
}