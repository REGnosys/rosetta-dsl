/*
 * generated by Xtext 2.10.0
 */
package com.regnosys.rosetta.ui.contentassist

import com.google.common.base.Function
import com.google.common.base.Predicate
import com.google.common.base.Predicates
import com.google.inject.Inject
import com.regnosys.rosetta.RosettaExtensions
import com.regnosys.rosetta.rosetta.RosettaBinaryOperation
import com.regnosys.rosetta.rosetta.RosettaEvent
import com.regnosys.rosetta.rosetta.RosettaProduct
import com.regnosys.rosetta.rosetta.RosettaQualifiable
import com.regnosys.rosetta.types.REnumType
import com.regnosys.rosetta.types.RosettaTypeProvider
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

import static com.regnosys.rosetta.rosetta.RosettaPackage.Literals.*
import com.regnosys.rosetta.utils.RosettaConfigExtension

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class RosettaProposalProvider extends AbstractRosettaProposalProvider {

	@Inject extension RosettaTypeProvider
	@Inject extension RosettaExtensions
	@Inject extension RosettaConfigExtension
	
	@Inject IQualifiedNameProvider qNames

	override protected lookupCrossReference(
		EObject model,
		EReference reference,
		ICompletionProposalAcceptor acceptor,
		Predicate<IEObjectDescription> filter,
		Function<IEObjectDescription, ICompletionProposal> proposalFactory
	) {
		val expectedType = switch (model) {
			RosettaBinaryOperation: {
				model.left?.RType
			}
		}
		if (expectedType instanceof REnumType) {
			expectedType.enumeration.allEnumValues.forEach [ enumValue |
				acceptor.accept(
					proposalFactory.apply(
						EObjectDescription.create(qNames.getFullyQualifiedName(enumValue), enumValue)))
			]
			return
		}
		super.lookupCrossReference(model, reference, acceptor, filter, proposalFactory)
	}
	
	override void completeRosettaEvent_AndDataRules(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		lookupCrossReference(((assignment.getTerminal() as CrossReference)), context, acceptor, [eObjDesc | eObjDesc.EClass == ROSETTA_DATA_RULE]) 
	}
	override void completeRosettaEvent_OrDataRules(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		lookupCrossReference(((assignment.getTerminal() as CrossReference)), context, acceptor, [eObjDesc | eObjDesc.EClass == ROSETTA_DATA_RULE]) 
	}
	
	override protected void lookupCrossReference(CrossReference crossReference,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if (crossReference.type.classifier == ROSETTA_CALLABLE ||
			crossReference.type.classifier == ROSETTA_ENUMERATION) {
			val rosettaQualifiable = EcoreUtil2.getContainerOfType(context.currentModel, RosettaQualifiable) ?:
				EcoreUtil2.getContainerOfType(context.previousModel, RosettaQualifiable)
			var Predicate<IEObjectDescription> filter = switch (rosettaQualifiable) {
				RosettaEvent:
					[ objDesc |
						objDesc.isEventAlias(rosettaQualifiable) || objDesc.isEventRootClass(rosettaQualifiable)
					]
				RosettaProduct:
					[ objDesc |
						objDesc.isProductAlias(rosettaQualifiable) || objDesc.isProductRootClass(rosettaQualifiable)
					]
				default:
					Predicates.alwaysTrue()
			}
			lookupCrossReference(crossReference, context, acceptor, filter)
		} else {
			lookupCrossReference(crossReference, context, acceptor, Predicates.alwaysTrue())
		}
	}

	
}
